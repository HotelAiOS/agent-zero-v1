"""
Workspace Extension - rozszerza TW√ìJ istniejƒÖcy test_ai_agents.py
Dodaje workspace management bez ≈Çamania existing kodu
"""
import os
import json
import uuid
import asyncio
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional
from dataclasses import dataclass

@dataclass
class WorkspaceFile:
    file_id: str
    filename: str
    content: str
    agent_id: str
    task_id: str
    created_at: datetime
    file_path: Path

class WorkspaceExtension:
    """Rozszerza TW√ìJ system o workspace management"""
    
    def __init__(self, base_dir: str = "./agent_zero_workspaces"):
        self.base_path = Path(base_dir)
        self.base_path.mkdir(exist_ok=True)
        self.workspace_id = None
        self.workspace_path = None
        self.files: Dict[str, WorkspaceFile] = {}
        
    async def initialize_workspace(self, project_name: str = "Agent Zero Project"):
        """Inicjalizuj workspace"""
        self.workspace_id = f"ws-{uuid.uuid4().hex[:8]}"
        self.workspace_path = self.base_path / self.workspace_id
        self.workspace_path.mkdir(exist_ok=True)
        
        # Utw√≥rz strukturƒô
        (self.workspace_path / "src").mkdir(exist_ok=True)
        (self.workspace_path / "tests").mkdir(exist_ok=True)
        (self.workspace_path / "docs").mkdir(exist_ok=True)
        
        # Config
        config = {
            "workspace_id": self.workspace_id,
            "project_name": project_name,
            "created_at": datetime.now().isoformat(),
            "generated_by": "agent_zero"
        }
        
        with open(self.workspace_path / "workspace_config.json", 'w') as f:
            json.dump(config, f, indent=2)
        
        # README
        readme = f"""# {project_name}

Generated by Agent Zero AI system.

## Workspace Info
- ID: {self.workspace_id}
- Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- Path: {self.workspace_path}

## Generated Files
This directory contains AI-generated code from autonomous agents.

## Usage
Check the `src/` directory for generated Python code.
"""
        
        with open(self.workspace_path / "README.md", 'w') as f:
            f.write(readme)
        
        print(f"üìÅ Workspace initialized: {self.workspace_id}")
        print(f"   Path: {self.workspace_path}")
        
        return self.workspace_id
    
    async def save_generated_code(self, code: str, agent_id: str, task_id: str, filename: str = None):
        """Zapisz wygenerowany kod"""
        if not self.workspace_path:
            await self.initialize_workspace()
        
        if not filename:
            filename = f"generated_code_{int(datetime.now().timestamp())}.py"
        
        file_path = self.workspace_path / "src" / filename
        
        # Zapisz plik
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(code)
        
        # Zapisz metadata
        file_id = f"file-{uuid.uuid4().hex[:8]}"
        workspace_file = WorkspaceFile(
            file_id=file_id,
            filename=filename,
            content=code,
            agent_id=agent_id,
            task_id=task_id,
            created_at=datetime.now(),
            file_path=file_path
        )
        
        self.files[file_id] = workspace_file
        
        print(f"üíæ Saved to workspace: {filename} ({len(code)} chars)")
        print(f"   Agent: {agent_id}")
        print(f"   Path: {file_path}")
        
        return file_id
    
    def get_workspace_summary(self):
        """Podsumowanie workspace"""
        if not self.workspace_path:
            return "No workspace initialized"
        
        total_files = len(self.files)
        total_code_chars = sum(len(f.content) for f in self.files.values())
        
        return {
            "workspace_id": self.workspace_id,
            "workspace_path": str(self.workspace_path),
            "total_files": total_files,
            "total_code_chars": total_code_chars,
            "files": [
                {
                    "filename": f.filename,
                    "agent_id": f.agent_id,
                    "size": len(f.content),
                    "created_at": f.created_at.isoformat()
                }
                for f in self.files.values()
            ]
        }

# Monkey patch dla TWOJEGO istniejƒÖcego test_ai_agents.py
class AgentZeroWorkspaceIntegration:
    """Integracja z TWOIM istniejƒÖcym systemem"""
    
    def __init__(self):
        self.workspace = WorkspaceExtension()
        self.original_handlers = {}
        
    async def enhance_existing_test(self):
        """Rozszerz istniejƒÖcy test o workspace"""
        
        print("\nüîß ENHANCING EXISTING TEST WITH WORKSPACE...")
        
        # Initialize workspace
        await self.workspace.initialize_workspace("AI Generated SaaS Platform")
        
        return self.workspace
    
    def create_enhanced_handler(self, original_handler, workspace):
        """Utw√≥rz enhanced handler wrapper"""
        
        async def enhanced_handler(message):
            # Wywo≈Çaj original handler
            if original_handler:
                result = await original_handler(message)
            
            # Extract code from message/result i zapisz do workspace
            task = message.get('data', {})
            
            # Tutaj logika do wydobywania kodu - dostosuj do TWOJEGO systemu
            if 'code' in str(message) or 'generated_code' in str(message):
                # Przyk≈Çadowe wydobywanie - dostosuj do TWOJEJ struktury
                try:
                    code_content = self._extract_code_from_message(message)
                    if code_content:
                        await workspace.save_generated_code(
                            code=code_content,
                            agent_id=message.get('from', 'unknown_agent'),
                            task_id=str(uuid.uuid4().hex[:8]),
                            filename=f"ai_generated_{int(datetime.now().timestamp())}.py"
                        )
                except Exception as e:
                    print(f"‚ö†Ô∏è Workspace save error: {e}")
            
            return result if 'result' in locals() else None
        
        return enhanced_handler
    
    def _extract_code_from_message(self, message):
        """WydobƒÖd≈∫ kod z wiadomo≈õci - dostosuj do TWOJEJ struktury"""
        # Przyk≈Çadowa logika - zmie≈Ñ na TWOJƒÑ strukturƒô danych
        data = message.get('data', {})
        
        # Szukaj w r√≥≈ºnych miejscach
        if 'generated_code' in data:
            return data['generated_code']
        elif 'code' in data:
            return data['code']
        elif 'result' in data and 'code' in data['result']:
            return data['result']['code']
        
        # Szukaj w string representation
        message_str = str(message)
        if 'from fastapi' in message_str.lower() or 'def ' in message_str:
            # Prawdopodobnie zawiera kod
            lines = message_str.split('\n')
            code_lines = []
            in_code_block = False
            
            for line in lines:
                if 'from fastapi' in line or 'def ' in line:
                    in_code_block = True
                
                if in_code_block:
                    code_lines.append(line)
            
            if code_lines:
                return '\n'.join(code_lines)
        
        return None

# PROSTY TEST INTEGRATION
async def test_workspace_with_existing_system():
    """Test workspace integration z istniejƒÖcym systemem"""
    
    print("="*60)
    print("üß™ WORKSPACE INTEGRATION TEST")  
    print("="*60)
    
    # Initialize workspace extension
    integration = AgentZeroWorkspaceIntegration()
    workspace = await integration.enhance_existing_test()
    
    print("\nüìù Testing workspace file creation...")
    
    # Simulate code generation (jak TW√ìJ system)
    sample_codes = [
        {
            "code": '''from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel
from typing import Optional

app = FastAPI(title="Agent Zero Auth API")

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

class UserLogin(BaseModel):
    username: str
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str

@app.post("/login", response_model=Token)
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
    # Authentication logic here
    if form_data.username == "admin" and form_data.password == "secret":
        return {"access_token": "fake-jwt-token", "token_type": "bearer"}
    else:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

@app.get("/protected")
async def protected_route(token: str = Depends(oauth2_scheme)):
    return {"message": "This is a protected route", "token": token}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
''',
            "agent_id": "backend_ai_001",
            "filename": "auth_endpoints.py"
        },
        {
            "code": '''import pytest
from fastapi.testclient import TestClient
from auth_endpoints import app

client = TestClient(app)

def test_login_success():
    response = client.post(
        "/login",
        data={"username": "admin", "password": "secret"}
    )
    assert response.status_code == 200
    assert "access_token" in response.json()

def test_login_failure():
    response = client.post(
        "/login", 
        data={"username": "wrong", "password": "wrong"}
    )
    assert response.status_code == 401

def test_protected_route():
    # First login
    login_response = client.post(
        "/login",
        data={"username": "admin", "password": "secret"}
    )
    token = login_response.json()["access_token"]
    
    # Access protected route
    response = client.get(
        "/protected",
        headers={"Authorization": f"Bearer {token}"}
    )
    assert response.status_code == 200
    assert "message" in response.json()

if __name__ == "__main__":
    pytest.main([__file__])
''',
            "agent_id": "test_ai_001", 
            "filename": "test_auth.py"
        },
        {
            "code": '''# AI Generated Database Models
from sqlalchemy import Column, Integer, String, DateTime, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.sql import func
from passlib.context import CryptContext

Base = declarative_base()
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, index=True, nullable=False)
    email = Column(String(100), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True)
    is_admin = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    def verify_password(self, password: str) -> bool:
        return pwd_context.verify(password, self.hashed_password)
    
    @classmethod
    def hash_password(cls, password: str) -> str:
        return pwd_context.hash(password)

class RefreshToken(Base):
    __tablename__ = "refresh_tokens"
    
    id = Column(Integer, primary_key=True, index=True)
    token = Column(String(255), unique=True, index=True, nullable=False)
    user_id = Column(Integer, nullable=False)
    expires_at = Column(DateTime(timezone=True), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    is_revoked = Column(Boolean, default=False)
''',
            "agent_id": "database_ai_001",
            "filename": "models.py"
        }
    ]
    
    # Save sample codes
    for i, sample in enumerate(sample_codes, 1):
        print(f"\nüìù Step {i}: Saving {sample['filename']}...")
        
        file_id = await workspace.save_generated_code(
            code=sample['code'],
            agent_id=sample['agent_id'],
            task_id=f"task_{i:03d}",
            filename=sample['filename']
        )
        
        print(f"   ‚úÖ Saved as: {file_id}")
    
    # Add requirements.txt
    print(f"\nüìù Step 4: Creating requirements.txt...")
    requirements = '''fastapi==0.104.1
uvicorn[standard]==0.24.0
pydantic==2.4.2
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6
sqlalchemy==2.0.23
pytest==7.4.3
httpx==0.25.2
'''
    
    req_file = workspace.workspace_path / "requirements.txt"
    with open(req_file, 'w') as f:
        f.write(requirements)
    
    print(f"   ‚úÖ Created requirements.txt")
    
    # Show workspace summary
    print(f"\nüìä WORKSPACE SUMMARY:")
    print("="*40)
    
    summary = workspace.get_workspace_summary()
    print(f"Workspace ID: {summary['workspace_id']}")
    print(f"Path: {summary['workspace_path']}")
    print(f"Files: {summary['total_files']}")
    print(f"Code: {summary['total_code_chars']} characters")
    
    print(f"\nüìÅ Generated Files:")
    for file_info in summary['files']:
        print(f"   üêç {file_info['filename']} ({file_info['size']} chars)")
        print(f"      Agent: {file_info['agent_id']}")
    
    # Show directory structure
    print(f"\nüìÇ Directory Structure:")
    for item in sorted(workspace.workspace_path.rglob("*")):
        if item.is_file():
            rel_path = item.relative_to(workspace.workspace_path)
            size = item.stat().st_size
            print(f"   üìÑ {rel_path} ({size} bytes)")
    
    print(f"\n‚úÖ WORKSPACE INTEGRATION TEST COMPLETED!")
    print(f"üóÇÔ∏è  Your project is ready at: {workspace.workspace_path}")
    print(f"üöÄ  Run: cd {workspace.workspace_path} && pip install -r requirements.txt")
    
    return workspace

# ROZSZERZENIE TWOJEGO ISTNIEJƒÑCEGO TESTU
async def enhance_your_existing_test():
    """Rozszerz TW√ìJ istniejƒÖcy test o workspace"""
    
    print("\n" + "üîß" * 20 + " WORKSPACE ENHANCEMENT " + "üîß" * 20)
    
    # Ten kod mo≈ºna dodaƒá na koniec TWOJEGO istniejƒÖcego test_ai_agents.py
    workspace_integration = AgentZeroWorkspaceIntegration()
    workspace = await workspace_integration.enhance_existing_test()
    
    print("‚úÖ Workspace enhancement ready!")
    print("üîó Now your existing agents will ALSO save to workspace files!")
    
    return workspace

if __name__ == "__main__":
    # Test standalone
    asyncio.run(test_workspace_with_existing_system())
    
    # Albo dodaj do existing test:
    # asyncio.run(enhance_your_existing_test())
