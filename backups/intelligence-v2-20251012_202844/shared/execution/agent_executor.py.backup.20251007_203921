"""
Agent Executor - Enhanced Multi-Agent Task Execution Engine
===========================================================

This module provides the AgentExecutor class with fixed method signature
for proper task execution with output directory support.

Author: Agent Zero V1 Development Team  
Status: COMPLETED - Fixed execute_task signature with output_dir parameter
Last Updated: 2025-10-07
"""

import os
import sys
import asyncio
import logging
import traceback
from typing import Dict, Any, Optional, List, Union
from pathlib import Path
from datetime import datetime
import json

# Neo4j integration (if available)
try:
    from shared.knowledge.neo4j_client import Neo4jClient
except ImportError:
    Neo4jClient = None

# RabbitMQ integration (if available)  
try:
    from shared.messaging.rabbitmq_client import RabbitMQClient
except ImportError:
    RabbitMQClient = None


class AgentExecutorError(Exception):
    """Custom exception for AgentExecutor errors"""
    pass


class AgentExecutor:
    """
    Enhanced Agent Executor with proper method signature and error handling.
    
    This class handles task execution for the Agent Zero V1 multi-agent platform.
    Key Features:
    - Fixed execute_task method signature with output_dir parameter
    - Comprehensive parameter validation
    - Neo4j knowledge base integration
    - RabbitMQ messaging support
    - Detailed logging and error handling
    """
    
    def __init__(self, 
                 neo4j_client: Optional[Neo4jClient] = None,
                 rabbitmq_client: Optional[RabbitMQClient] = None,
                 log_level: str = "INFO"):
        """
        Initialize AgentExecutor with optional integrations.
        
        Args:
            neo4j_client: Optional Neo4j client for knowledge storage
            rabbitmq_client: Optional RabbitMQ client for messaging
            log_level: Logging level (DEBUG, INFO, WARNING, ERROR)
        """
        self.neo4j_client = neo4j_client
        self.rabbitmq_client = rabbitmq_client
        
        # Setup logging
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(getattr(logging, log_level.upper()))
        
        # Create console handler if not exists
        if not self.logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                '[%(asctime)s] %(name)s - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            self.logger.addHandler(handler)
            
        self.logger.info("AgentExecutor initialized successfully")
        
        # Execution statistics
        self.stats = {
            'tasks_executed': 0,
            'tasks_successful': 0,
            'tasks_failed': 0,
            'total_execution_time': 0.0
        }
    
    def execute_task(self, 
                    agent: Any, 
                    task: Dict[str, Any], 
                    output_dir: str) -> Dict[str, Any]:
        """
        Execute a task with the specified agent and output directory.
        
        **FIXED METHOD SIGNATURE** - Now includes required output_dir parameter
        
        Args:
            agent: The agent instance to execute the task
            task: Task dictionary containing task details
            output_dir: Directory path for task output files
            
        Returns:
            Dict containing execution results and metadata
            
        Raises:
            AgentExecutorError: If task execution fails
            ValueError: If parameters are invalid
        """
        start_time = datetime.now()
        task_id = task.get('id', f"task_{int(start_time.timestamp())}")
        
        try:
            # Parameter validation
            self._validate_parameters(agent, task, output_dir)
            
            self.logger.info(f"Starting task execution: {task_id}")
            self.logger.debug(f"Task details: {json.dumps(task, indent=2)}")
            self.logger.debug(f"Output directory: {output_dir}")
            
            # Ensure output directory exists
            output_path = Path(output_dir)
            output_path.mkdir(parents=True, exist_ok=True)
            
            # Pre-execution setup
            execution_context = self._setup_execution_context(agent, task, output_dir)
            
            # Execute the actual task
            result = self._execute_core_task(agent, task, execution_context)
            
            # Post-execution processing
            final_result = self._process_task_results(result, execution_context)
            
            # Update statistics
            execution_time = (datetime.now() - start_time).total_seconds()
            self.stats['tasks_executed'] += 1
            self.stats['tasks_successful'] += 1
            self.stats['total_execution_time'] += execution_time
            
            self.logger.info(f"Task {task_id} completed successfully in {execution_time:.2f}s")
            
            return final_result
            
        except Exception as e:
            # Error handling and logging
            execution_time = (datetime.now() - start_time).total_seconds()
            self.stats['tasks_executed'] += 1
            self.stats['tasks_failed'] += 1
            self.stats['total_execution_time'] += execution_time
            
            error_msg = f"Task {task_id} failed after {execution_time:.2f}s: {str(e)}"
            self.logger.error(error_msg)
            self.logger.debug(f"Full traceback: {traceback.format_exc()}")
            
            # Save error information to output directory if possible
            try:
                error_file = Path(output_dir) / f"error_{task_id}.json"
                error_data = {
                    'task_id': task_id,
                    'error_message': str(e),
                    'error_type': type(e).__name__,
                    'traceback': traceback.format_exc(),
                    'timestamp': start_time.isoformat(),
                    'execution_time': execution_time
                }
                with open(error_file, 'w') as f:
                    json.dump(error_data, f, indent=2)
            except Exception as save_error:
                self.logger.warning(f"Could not save error log: {save_error}")
            
            raise AgentExecutorError(error_msg) from e
    
    def _validate_parameters(self, agent: Any, task: Dict[str, Any], output_dir: str) -> None:
        """Validate input parameters for execute_task method."""
        if agent is None:
            raise ValueError("Agent parameter cannot be None")
            
        if not isinstance(task, dict):
            raise ValueError("Task parameter must be a dictionary")
            
        if not task:
            raise ValueError("Task dictionary cannot be empty")
            
        if not isinstance(output_dir, str):
            raise ValueError("Output directory must be a string")
            
        if not output_dir.strip():
            raise ValueError("Output directory cannot be empty")
            
        # Validate task structure
        required_fields = ['id', 'type', 'description']
        missing_fields = [field for field in required_fields if field not in task]
        if missing_fields:
            self.logger.warning(f"Task missing recommended fields: {missing_fields}")
    
    def _setup_execution_context(self, agent: Any, task: Dict[str, Any], output_dir: str) -> Dict[str, Any]:
        """Setup execution context for the task."""
        context = {
            'agent': agent,
            'task': task,
            'output_dir': output_dir,
            'start_time': datetime.now(),
            'temp_files': [],
            'resources': {}
        }
        
        # Initialize Neo4j connection if available
        if self.neo4j_client:
            try:
                context['knowledge_session'] = self.neo4j_client.get_session()
                self.logger.debug("Neo4j session initialized for task execution")
            except Exception as e:
                self.logger.warning(f"Could not initialize Neo4j session: {e}")
        
        # Initialize RabbitMQ connection if available
        if self.rabbitmq_client:
            try:
                context['messaging_channel'] = self.rabbitmq_client.get_channel()
                self.logger.debug("RabbitMQ channel initialized for task execution")
            except Exception as e:
                self.logger.warning(f"Could not initialize RabbitMQ channel: {e}")
        
        return context
    
    def _execute_core_task(self, agent: Any, task: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the core task logic."""
        task_type = task.get('type', 'generic')
        
        self.logger.debug(f"Executing task of type: {task_type}")
        
        # Check if agent has a execute method
        if hasattr(agent, 'execute'):
            result = agent.execute(task, context)
        elif hasattr(agent, 'run'):
            result = agent.run(task, context)
        elif hasattr(agent, 'process'):
            result = agent.process(task, context)
        else:
            # Generic task execution
            result = self._generic_task_execution(agent, task, context)
        
        return result
    
    def _generic_task_execution(self, agent: Any, task: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """Generic task execution when agent doesn't have specific methods."""
        self.logger.info("Using generic task execution method")
        
        result = {
            'status': 'completed',
            'message': f"Task {task.get('id')} executed using generic method",
            'agent_type': type(agent).__name__,
            'task_type': task.get('type', 'unknown'),
            'output_files': [],
            'metadata': {}
        }
        
        # Save basic task info to output directory
        output_file = Path(context['output_dir']) / f"task_{task.get('id', 'unknown')}_result.json"
        with open(output_file, 'w') as f:
            json.dump({
                'task': task,
                'result': result,
                'timestamp': datetime.now().isoformat()
            }, f, indent=2)
        
        result['output_files'].append(str(output_file))
        
        return result
    
    def _process_task_results(self, result: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """Process and enhance task results."""
        execution_time = (datetime.now() - context['start_time']).total_seconds()
        
        # Enhance result with execution metadata
        enhanced_result = {
            **result,
            'execution_metadata': {
                'execution_time': execution_time,
                'timestamp': datetime.now().isoformat(),
                'output_directory': context['output_dir'],
                'agent_type': type(context['agent']).__name__,
                'task_id': context['task'].get('id'),
                'executor_version': '1.0.0'
            }
        }
        
        # Store result in Neo4j if available
        if context.get('knowledge_session'):
            try:
                self._store_result_in_neo4j(enhanced_result, context)
            except Exception as e:
                self.logger.warning(f"Could not store result in Neo4j: {e}")
        
        # Send completion message via RabbitMQ if available
        if context.get('messaging_channel'):
            try:
                self._send_completion_message(enhanced_result, context)
            except Exception as e:
                self.logger.warning(f"Could not send completion message: {e}")
        
        # Cleanup resources
        self._cleanup_execution_context(context)
        
        return enhanced_result
    
    def _store_result_in_neo4j(self, result: Dict[str, Any], context: Dict[str, Any]) -> None:
        """Store execution result in Neo4j knowledge base."""
        query = """
        CREATE (execution:TaskExecution {
            task_id: $task_id,
            agent_type: $agent_type,
            status: $status,
            execution_time: $execution_time,
            timestamp: $timestamp,
            result_data: $result_data
        })
        """
        
        params = {
            'task_id': context['task'].get('id'),
            'agent_type': type(context['agent']).__name__,
            'status': result.get('status'),
            'execution_time': result.get('execution_metadata', {}).get('execution_time'),
            'timestamp': result.get('execution_metadata', {}).get('timestamp'),
            'result_data': json.dumps(result)
        }
        
        context['knowledge_session'].run(query, params)
        self.logger.debug("Task result stored in Neo4j")
    
    def _send_completion_message(self, result: Dict[str, Any], context: Dict[str, Any]) -> None:
        """Send task completion message via RabbitMQ."""
        message = {
            'event': 'task_completed',
            'task_id': context['task'].get('id'),
            'agent_type': type(context['agent']).__name__,
            'status': result.get('status'),
            'timestamp': result.get('execution_metadata', {}).get('timestamp')
        }
        
        context['messaging_channel'].basic_publish(
            exchange='agent_zero_events',
            routing_key='task.completed',
            body=json.dumps(message)
        )
        self.logger.debug("Task completion message sent via RabbitMQ")
    
    def _cleanup_execution_context(self, context: Dict[str, Any]) -> None:
        """Cleanup resources from execution context."""
        # Close Neo4j session
        if context.get('knowledge_session'):
            try:
                context['knowledge_session'].close()
            except Exception as e:
                self.logger.warning(f"Error closing Neo4j session: {e}")
        
        # Close RabbitMQ channel
        if context.get('messaging_channel'):
            try:
                context['messaging_channel'].close()
            except Exception as e:
                self.logger.warning(f"Error closing RabbitMQ channel: {e}")
        
        # Clean up temporary files
        for temp_file in context.get('temp_files', []):
            try:
                if os.path.exists(temp_file):
                    os.remove(temp_file)
            except Exception as e:
                self.logger.warning(f"Could not remove temp file {temp_file}: {e}")
    
    def get_execution_stats(self) -> Dict[str, Any]:
        """Get execution statistics."""
        stats = self.stats.copy()
        if stats['tasks_executed'] > 0:
            stats['success_rate'] = stats['tasks_successful'] / stats['tasks_executed']
            stats['average_execution_time'] = stats['total_execution_time'] / stats['tasks_executed']
        else:
            stats['success_rate'] = 0.0
            stats['average_execution_time'] = 0.0
        
        return stats
    
    def reset_stats(self) -> None:
        """Reset execution statistics."""
        self.stats = {
            'tasks_executed': 0,
            'tasks_successful': 0,
            'tasks_failed': 0,
            'total_execution_time': 0.0
        }
        self.logger.info("Execution statistics reset")


# Async version for compatibility
class AsyncAgentExecutor(AgentExecutor):
    """Async version of AgentExecutor for async agent compatibility."""
    
    async def execute_task(self, 
                          agent: Any, 
                          task: Dict[str, Any], 
                          output_dir: str) -> Dict[str, Any]:
        """
        Async version of execute_task method.
        
        Args:
            agent: The agent instance to execute the task
            task: Task dictionary containing task details  
            output_dir: Directory path for task output files
            
        Returns:
            Dict containing execution results and metadata
        """
        # Run synchronous version in thread pool for compatibility
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(
            None, 
            super().execute_task, 
            agent, 
            task, 
            output_dir
        )


# Factory function for creating executor instances
def create_agent_executor(config: Optional[Dict[str, Any]] = None) -> AgentExecutor:
    """
    Factory function to create AgentExecutor with configuration.
    
    Args:
        config: Optional configuration dictionary with:
            - neo4j_config: Neo4j connection configuration
            - rabbitmq_config: RabbitMQ connection configuration  
            - log_level: Logging level
            - async_mode: Whether to return AsyncAgentExecutor
    
    Returns:
        AgentExecutor instance (sync or async based on config)
    """
    if config is None:
        config = {}
    
    # Initialize Neo4j client if configured
    neo4j_client = None
    if config.get('neo4j_config') and Neo4jClient:
        try:
            neo4j_client = Neo4jClient(**config['neo4j_config'])
        except Exception as e:
            logging.warning(f"Could not initialize Neo4j client: {e}")
    
    # Initialize RabbitMQ client if configured
    rabbitmq_client = None
    if config.get('rabbitmq_config') and RabbitMQClient:
        try:
            rabbitmq_client = RabbitMQClient(**config['rabbitmq_config'])
        except Exception as e:
            logging.warning(f"Could not initialize RabbitMQ client: {e}")
    
    # Create executor instance
    if config.get('async_mode', False):
        return AsyncAgentExecutor(
            neo4j_client=neo4j_client,
            rabbitmq_client=rabbitmq_client,
            log_level=config.get('log_level', 'INFO')
        )
    else:
        return AgentExecutor(
            neo4j_client=neo4j_client,
            rabbitmq_client=rabbitmq_client,
            log_level=config.get('log_level', 'INFO')
        )


if __name__ == "__main__":
    # Example usage and testing
    print("AgentExecutor - Method Signature Fix Implementation")
    print("=" * 60)
    
    # Create test executor
    executor = create_agent_executor({'log_level': 'DEBUG'})
    
    # Mock agent for testing
    class MockAgent:
        def execute(self, task, context):
            return {
                'status': 'completed',
                'message': 'Mock task executed successfully',
                'data': task.get('data', {})
            }
    
    # Test task
    test_task = {
        'id': 'test_001',
        'type': 'test',
        'description': 'Test task for AgentExecutor method signature fix',
        'data': {'test_param': 'test_value'}
    }
    
    # Test execution
    try:
        result = executor.execute_task(
            agent=MockAgent(),
            task=test_task,
            output_dir='./test_output'
        )
        
        print(f"✅ Test execution successful!")
        print(f"Task ID: {result['execution_metadata']['task_id']}")
        print(f"Execution Time: {result['execution_metadata']['execution_time']:.3f}s")
        print(f"Output Directory: {result['execution_metadata']['output_directory']}")
        
        # Show statistics
        stats = executor.get_execution_stats()
        print(f"\n📊 Execution Statistics:")
        print(f"Tasks Executed: {stats['tasks_executed']}")
        print(f"Success Rate: {stats['success_rate']:.2%}")
        print(f"Average Execution Time: {stats['average_execution_time']:.3f}s")
        
    except Exception as e:
        print(f"❌ Test execution failed: {e}")
        sys.exit(1)
    
    print("\n🎉 AgentExecutor method signature fix verified successfully!")